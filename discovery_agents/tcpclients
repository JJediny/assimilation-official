#!/bin/sh
#	@brief Command to discover processes that are clients of TCP services and output
#	the resuin JSON format.
#	@details Output validated at jsonlint.com (good to validate future versions there too!)
#
#	It makes use of netstat -tunp to get the active outbound connections, and /proc to
#	get more detailed information about the processes we discovered with netstat.
#
#	We get the listening protocol, port, protocol, address and process listening that address.
#	We get the binary full pathname, its arguments (if not modified by the application),
#	uid and gid, current directory and so on of the process communicating.
#
#	This isn't exactly rocket science, but integrating the /proc info with the netstat
#	info works out nicely, and the JSON output is nicely readable to humans and nicely
#	structured for machines - which is a plus.
#
#	You must be root to get full value out of this program (and avoid some warnings).
#	Sorry :-( Although we can get the ports without root, we cannot get detailed
#	information about the processes that are communicating - which is definitely worth having.
#
# @author &copy; 2012 - Alan Robertson <alanr@unix.sh>
# @n
# Licensed under the GNU General Public License (GPL) version 3 or any later version at your option.
#

skiplocal=yes
uid=`id -u`
if
  [ "$uid" -eq 0 ]
then
  asroot=yes
else
  asroot=no
fi


US=$(basename $0)
#
#	Grab interesting information from /proc for our processes
#
procinfo() {
  procpid="$1"
  EXE=$(readlink /proc/$procpid/exe)
  CMD=$(tr '\0' '' < /proc/$procpid/cmdline |  sed -e 's%$%%' -e 's%\\\\%\\\\\\\\%g' -e 's%"%\\"%g' -e 's%%", "%g' -e 's%.*%"cmdline": [ "&" ],\n%')
  USERID=$(ls -ld /proc/$procpid | cut -d' ' -f3)
  GROUPID=$(ls -ld /proc/$procpid | cut -d' ' -f4)
  cat <<-!FOO
	"exe": "$EXE",
	$CMD
	"uid": "$USERID",
	"gid": "$GROUPID",
	"cwd": "$(readlink /proc/$procpid/cwd)",
	!FOO
}

#
#	return True (exit code zero) if we should skip this IP address
#
shouldskip() {
  case "$1/$skiplocal" in
    "127.0.0.1/yes"|"::1/yes")	return 0;; # true
  esac
  return 1 # false
}

#
#	Output info on the set of listening processes, ports, ip addresses and so on...
#
#Output something good to sort this pid on...
# In the best case (as root) it will be the basename of the executable and the pid
# In the worst case (non-root) it will be the port twice...
procsortinfo() {
  procpid="$1"
  procport="$2"
  if
    [ -z "$procpid" -o "X$procpid" = 'X-' -o ! -f /proc/$procpid/cmdline -o ! -r /proc/$procpid/cmdline ]
  then
    printf '%s\t%s\n' "${procport}" "${procport}"
    return 0
  fi
  EXE=$(basename $(readlink /proc/$procpid/exe))
  ARGS=$(tr -d '\0' < /proc/$procpid/cmdline)
  printf '%s\t%s\n' "${EXE}" "${pid}"
}


netstatinfo()
{
  flags=-ntp
    netstat $flags | 
    while
       read proto rcvq sendq localaddr foreignaddr state pid_prog
    do
      case $state in
        [A-Z][A-Z]*)	: OK;;
        *)	: state is ["$state"] ; continue;;
      esac

      pid=$(dirname "$pid_prog")			# Strip all after & including /
      addr=$(echo "$foreignaddr" | sed 's%:[^:]*$%%')	# Strip all starting from last ':'
      port=$(echo "$foreignaddr" | sed 's%.*:%%')	# Strip all before & including last ':'
      pid=$(echo "$pid_prog"| sed 's%/.*%%')		# Strip all after & including /
      shouldskip "$addr" && continue
      printf "$(procsortinfo "$pid" "$port")\t${proto}\t${addr}\t${port}\n"
    done | sort
}
process_netstat()
{
  lastpid=None
  lastname=None
  outercomma=''
  innercomma=''
  cat <<-!EOF
	{
	  "discovertype": "tcpclients",
	  "description": "TCP Client Processes",
	  "source": "$US",
	  "host": "$(uname -n)",
	  "data": {
	!EOF
  seq=1
  netstatinfo |
  while
      read name pid proto addr port
  do
      if
        [ "X$pid" != "X$lastpid" -o "X$name" != "X$lastname" ]
      then
        if 
          [ "X$name" = "X$lastname" ]
        then
          pname="${name}-${seq}"
          seq=$(expr $seq + 1)
        else
          seq=1
          pname="${name}"
        fi
        if
          [ "$innercomma" != '' ]
        then
	  printf '\n        }\n      }\n'
        fi
        
	printf '%s    "%s": {\n' "$outercomma" "$pname"
        lastpid="$pid"
        lastname="$name"
        outercomma='    },
'
        innercomma=''
        if
          [ "$name" != "$pid" ]
	then
          procinfo "$pid" | sed 's%^%      %'
        elif
          [ "$asroot" = yes ]
        then
          printf '      "exe": "(kernel)",\n'
        else
          printf '      "exe": "unknown",\n'
          
        fi
        printf '      "clientaddrs": {\n'
      fi
      cat <<-!FOO
	${innercomma}        "${addr}:${port}": {
	          "proto": "$proto",
	          "addr": "$addr",
	!FOO
	printf '          "port": %s' "$port"
	innercomma='
        },
'
  done
  cat <<-!STAT

	        }
	      }
	    }
	  }
	}
	!STAT
}

#
#	Need to think about standardizing arguments and commands given to discovery
#	modules and standardize them.  That means some things will likely change as
#	I get smart enough to see what I should have done in the first place.
#
#netstatinfo
process_netstat
exit 0
discover ${1-tcp}
