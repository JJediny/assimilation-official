#!/bin/sh
#	@brief Command to discover processes listening for connections (tcp) or packets (udp)
#	and output the results in JSON format.
#	@details Output validated at jsonlint.com (good to validate future versions there too!)
#
#	It makes use of netstat -[tu]lnp to get the active listening connections, and /proc to
#	get more detailed information about the processes we discovered with netstat.
#
#	We get the listening protocol, port, protocol, address and process listening that address.
#	We get the binary full pathname, its arguments (if not modified by the application),
#	uid and gid, current directory and so on of the process communicating.
#
#	For TCP programs we only output listening processes.  For UDP, there is no such thing
#	as listening processes, so you get the whole set of processes prepared to receive
#	(or send) UDP packets.
#
#	This isn't exactly rocket science, but integrating the /proc info with the netstat
#	info works out nicely, and the JSON output is nicely readable to humans and nicely
#	structured for machines - which is a plus.
#
#	You must be root to get full value out of this program (and avoid some warnings).
#	Sorry :-( Although we can get the listening ports without root, we cannot get detailed
#	information about the processes that are communicating - which is definitely worth having.
#
# @author &copy; 2012 - Alan Robertson <alanr@unix.sh>
# @n
# Licensed under the GNU General Public License (GPL) version 3 or any later version at your option.
#

skiplocal=yes

US=$(basename $0)
#
#	Grab interesting information from /proc for our processes
#
procinfo() {
  procpid="$1"
  if
    [ -z "$1" -o ! -f /proc/$procpid/cmdline -o ! -r /proc/$procpid/cmdline ]
  then
    printf '"exe": "unknown"\n'
    return
  fi
  EXE=$(readlink /proc/$procpid/exe)
  CMD=$(tr '\0' '' < /proc/$procpid/cmdline |  sed -e 's%$%%' -e 's%\\\\%\\\\\\\\%g' -e 's%"%\\"%g' -e 's%%", "%g' -e 's%.*%"cmdline": [ "&" ],\n%')
  UID=$(ls -ld /proc/$procpid | cut -d' ' -f3)
  GID=$(ls -ld /proc/$procpid | cut -d' ' -f4)
  cat <<-!FOO
	"pid": $pid,
	"exe": "$EXE",
	$CMD
	"uid": "$UID",
	"gid": "$GID",
	"cwd": "$(readlink /proc/$procpid/cwd)"
	!FOO
}

#
#	return True (exit code zero) if we should skip this IP address
#
shouldskip() {
  case "$1/$skiplocal" in
    "127.0.0.1/yes"|"::1/yes")	return 0;; # true
  esac
  return 1 # false
}

#
#	Output info on the set of listening processes, ports, ip addresses and so on...
#
discover() {
  cat <<-!EOF
	{
	    "discovertype": "listeningprocs",
	    "description": "${1-all} Listening Processes",
	    "source": "$US",
	    "host": "$(uname -n)",
	    "data": {
	!EOF
    case $1 in
      tcp)	flags=-tnlp;;
      udp)	flags=-unlp;;
      *)	flags=-utnlp;;
    esac

    # This 'comma' variable is for avoiding ending the set of object values with a comma
    comma=''
    #
    # Examine all our netstat output (after mangling it) to see what services we're offering
    #
    netstat $flags | 
    while
       read proto rcvq sendq localaddr foreignaddr state pid_prog
    do
      : proto $proto rcvq $rcvq sendq $sendq localaddr $localaddr foreignaddr $foreignaddr state $state pid_prog $pid_prog
      case $state in
        LISTEN)	: OK;;
        */*)	pid_prog="$state";;
        *)	: state is ["$state"] ; continue;;
      esac
      addr=$(echo "$localaddr" | sed 's%:[^:]*$%%')	# Strip all starting from last ':'
      port=$(echo "$localaddr" | sed 's%.*:%%')		# Strip all before & including last ':'
      pid=$(echo "$pid_prog"| sed 's%/.*%%')		# Strip all after & including /
      
      shouldskip "$addr" && continue
      
      key="$proto/$addr/$port"
      printf "$comma"
      cat <<-!FOO
	"$key": {
	    "proto": "$proto",
	    "addr": "$addr",
	    "port": $port,
	!FOO
      procinfo $pid | sed 's%^%    %'
      printf "}"  # newline deliberately omitted - see $comma below
      comma=",\n" # Any future outputs will have a comma in front of them.
    done | sed 's%^%	%'
    # This leaves us one newline short, so it appears first thing below.
    cat <<-!FOO2

	    }
	}
	!FOO2
}

#
#	Need to think about standardizing arguments and commands given to discovery
#	modules and standardize them.  That means some things will likely change as
#	I get smart enough to see what I should have done in the first place.
#
discover ${1-tcp}
