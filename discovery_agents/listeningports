#!/bin/sh
#	@brief Command to discover processes listening for connections (tcp) or packets (udp) and output the results in JSON format.
#	@details Output validated at jsonlint.com (good to validate future versions there too!)
#
#	It makes use of netstat -[tu]lnp to get the active listening connections, and /proc to get more detailed information about
#	the processes we discovered with netstat.
#
#	We get the listening protocol, port, protocol, address and process listening that address.  We get the binary full pathname,
#	its arguments (if not modified by the application), uid and gid, current directory and so on of the process communicating.
#
#	For TCP programs we only output listening processes.  For UDP, there is no such thing as listening processes, so you
#	get the whole set of processes prepared to receive (or send) UDP packets.
#
#	This isn't exactly rocket science, but integrating the /proc info with the netstat info works out nicely,
#	and the JSON output is pretty readable to humans and nicely structured for machines - which is a plus.
#	I deliberately left the pid out of the output because it might change periodically.
#
#	You must be root to get full value out of this program (and avoid some warnings).  Sorry :-(
#	Although we can get the listening ports without root, we cannot get detailed information about
#	the processes that are communicating - which is definitely worth having.
#
# @author &copy; 2012 - Alan Robertson <alanr@unix.sh>
# @n
# Licensed under the GNU General Public License (GPL) version 3 or any later version at your option.
#

skiplocal=yes

US=`basename $0`
#
#	Grab interesting information from /proc for our processes
#
procinfo() {
  procpid="$1"
  if
    [ ! -f /proc/$procpid/cmdline -o ! -r /proc/$procpid/cmdline ]
  then
    printf '"exe": "unknown"\n'
    return
  fi
  EXE=`readlink /proc/$procpid/exe`
  CMD=`tr '\0' '' < /proc/$procpid/cmdline |  sed -e 's%$%%' -e 's%\\\\%\\\\\\\\%g' -e 's%"%\\"%g' -e 's%%", "%g' -e 's%.*%"cmdline": [ "&" ],\n%'`
  UID=`ls -ld /proc/$procpid | cut -d' ' -f3`
  GID=`ls -ld /proc/$procpid | cut -d' ' -f4`
  cat <<-!FOO
	"exe": "$EXE",
	$CMD
	"uid": "$UID",
	"gid": "$GID",
	"cwd": "`readlink /proc/$procpid/cwd`"
	!FOO
}

shouldskip() {
  case "$1/$skiplocal" in
    "127.0.0.1/yes"|"::1/yes")	return 0;; # true
  esac
  return 1 # false
}

#
#	Output info on the set of listening processes, ports, ip addresses and so on...
#
discover() {
  cat <<-!EOF
	{
	    "discovertype": "listeningprocs",
	    "description": "${1-all} Listening Processes",
	    "source": "$US",
	    "host": "`uname -n`",
	    "data": {
	!EOF
    case $1 in
      tcp)	flags=-tnlp;;
      udp)	flags=-unlp;;
      *)	flags=-utnlp;;
    esac

    # This 'comma' variable is for avoiding ending the set of object values with a comma
    comma=''
    #
    # Examine all our netstat output (after mangling it) to see what services we're offering
    #
    netstat $flags | cut -c1-6,21-44,81- |
      sed -r -e 's%:[0-9][0-9]*  *% &%' 		\
	     -e 's% :([0-9])% &%'  			\
             -e 's%  *%\t%g' -e 's%/.*%%'  		\
             -e 's%	:([0-9])%	\1%' 		\
             -e 's%	:	%	::	%' |
      tail -n +3  |
    while
       read proto addr port pid other
    do
      shouldskip "$addr" && continue
      
      key="$proto/$addr/$port"
      printf "$comma"
      cat <<-!FOO
	"$key": {
	    "proto": "$proto",
	    "addr": "$addr",
	    "port": $port,
	!FOO
      procinfo $pid | sed 's%^%    %'
      printf "}"  # newline deliberately omitted - see $comma below
      comma=",\n" # Any future outputs will have a comma in front of them.
    done | sed 's%^%	%'
    # This leaves us one newline short, so it appears first thing below.
    cat <<-!FOO2

	    }
	}
	!FOO2
}

#
#	Need to think about standardizing arguments and commands given to discovery
#	modules and standardize them.  That means some things will likely change as
#	I get smart enough to see what I should have done in the first place.
#
discover ${1-tcp}
